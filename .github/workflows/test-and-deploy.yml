name: Test and Deploy

on:
  push:
    branches:
      - main
      - release/*

jobs:
  test:
    name: Unit and Integration Testing
    runs-on: ubuntu-latest
    environment: test
    services:
      postgres:
        image: postgres:17-alpine
        env:
          POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB: ${{ vars.POSTGRES_DB }}
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:8-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      minio:
        image: lazybit/minio
        ports:
          - 9000:9000
        env:
          MINIO_ACCESS_KEY: ${{ secrets.MINIO_ACCESS_KEY }}
          MINIO_SECRET_KEY: ${{ secrets.MINIO_SECRET_KEY }}
        volumes:
          - ${{ github.workspace }}/data:/data
        options: --name=minio --health-cmd "curl http://localhost:9000/minio/health/live"

    steps:
      - name: Setup MinIO
        run: |
          pip3 install minio
          python3 - <<'EOF'
          from minio import Minio
          from minio.error import S3Error

          try:
              minio = Minio(
                  'localhost:9000',
                  access_key='${{ secrets.MINIO_ACCESS_KEY }}',
                  secret_key='${{ secrets.MINIO_SECRET_KEY }}',
                  secure=False
              )
          except Exception as ex:
              raise

          minio.make_bucket('${{ vars.S3_TEST_BUCKET_NAME }}')
          EOF

      - name: Ensure data directory is deletable
        run: |
          pwd
          sudo chown -R $USER:$USER data/

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js runtime
        uses: actions/setup-node@v6
        with:
          node-version: 22

      - name: Install dependencies
        run: npm install

      - name: Run tests
        env:
          NODE_ENV: test
          PORT: ${{ secrets.PORT }}
          CORS_ORIGIN: ${{ vars.CORS_ORIGIN }}
          RATE_LIMITER_WINDOW_SEC: ${{ vars.RATE_LIMITER_WINDOW_SEC }}
          RATE_LIMITER_MAX_REQ: ${{ vars.RATE_LIMITER_MAX_REQ }}
          DATABASE_URL: postgres://${{ secrets.POSTGRES_USER }}:${{ secrets.POSTGRES_PASSWORD }}@localhost:5432/${{ vars.POSTGRES_DB }}
          JWT_SECRET_KEY: ${{ secrets.JWT_SECRET_KEY }}
          JWT_EXP: ${{ vars.JWT_EXP }}
          REDIS_URL: redis://@localhost:6379/0
          NODEMAILER_SENDER: ${{ secrets.NODEMAILER_SENDER }}
          NODEMAILER_USER: ${{ secrets.NODEMAILER_USER }}
          NODEMAILER_PASS: ${{ secrets.NODEMAILER_PASS }}
          NODEMAILER_HOST: ${{ secrets.NODEMAILER_HOST }}
          NODEMAILER_PORT: ${{ secrets.NODEMAILER_PORT }}
          S3_ENDPOINT: http://localhost:9000
          S3_ACCESS_KEY_ID: ${{ secrets.MINIO_ACCESS_KEY }}
          S3_SECRET_ACCESS_KEY: ${{ secrets.MINIO_SECRET_KEY }}
          S3_TEST_BUCKET_NAME: ${{ vars.S3_TEST_BUCKET_NAME }}
          S3_REGION: ${{ vars.S3_REGION }}
        run: npm run -s test:clean

  deploy:
    name: Auto Deploy to Amazon EC2
    runs-on: ubuntu-latest
    needs: [test]
    if: ${{ needs.test.result == 'success' }}
    environment: ${{ startsWith(github.ref, 'refs/heads/release/') && 'release' || 'production' }}
    env:
      AWS_INSTANCE_SG_ID: ${{ secrets.AWS_INSTANCE_SG_ID }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v5.1.0
        with:
          aws-region: ${{ secrets.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Get runner IP address
        id: ip
        uses: haythem/public-ip@v1.3

      - name: Whitelist runner IP address
        run: |
          aws ec2 authorize-security-group-ingress \
            --group-id $AWS_INSTANCE_SG_ID \
            --protocol tcp \
            --port 22 \
            --cidr ${{ steps.ip.outputs.ipv4 }}/32

      - name: Checkout code
        uses: actions/checkout@v4

      - name: SSH into EC2 & deploy with rollback
        uses: appleboy/ssh-action@v1.1.0
        env:
          NODE_ENV: production
          PORT: ${{ secrets.PORT }}
          HOST_NAME: ${{ secrets.HOST_NAME }}
          CORS_ORIGIN: ${{ secrets.CORS_ORIGIN }}
          RATE_LIMITER_WINDOW_SEC: ${{ secrets.RATE_LIMITER_WINDOW_SEC }}
          RATE_LIMITER_MAX_REQ: ${{ secrets.RATE_LIMITER_MAX_REQ }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          JWT_SECRET_KEY: ${{ secrets.JWT_SECRET_KEY }}
          JWT_EXP: ${{ secrets.JWT_EXP }}
          REDIS_URL: ${{ secrets.REDIS_URL }}
          NODEMAILER_SENDER: ${{ secrets.NODEMAILER_SENDER }}
          NODEMAILER_USER: ${{ secrets.NODEMAILER_USER }}
          NODEMAILER_PASS: ${{ secrets.NODEMAILER_PASS }}
          NODEMAILER_HOST: ${{ secrets.NODEMAILER_HOST }}
          NODEMAILER_PORT: ${{ secrets.NODEMAILER_PORT }}
          S3_ENDPOINT: ${{ secrets.S3_ENDPOINT }}
          S3_ACCESS_KEY_ID: ${{ secrets.S3_ACCESS_KEY_ID }}
          S3_SECRET_ACCESS_KEY: ${{ secrets.S3_SECRET_ACCESS_KEY }}
          S3_BUCKET_NAME: ${{ secrets.S3_BUCKET_NAME }}
          S3_REGION: ${{ secrets.S3_REGION }}
          DOCRAPTOR_API_KEY: ${{ secrets.DOCRAPTOR_API_KEY }}
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          envs: NODE_ENV, PORT, HOST_NAME, CORS_ORIGIN,  RATE_LIMITER_WINDOW_SEC, RATE_LIMITER_MAX_REQ, DATABASE_URL, JWT_SECRET_KEY, JWT_EXP, REDIS_URL, NODEMAILER_SENDER, NODEMAILER_USER, NODEMAILER_PASS, NODEMAILER_HOST, NODEMAILER_PORT, S3_ENDPOINT, S3_ACCESS_KEY_ID, S3_SECRET_ACCESS_KEY, S3_BUCKET_NAME, S3_REGION, DOCRAPTOR_API_KEY
          script: |
            set -e
            echo "Starting deployment on ${{ secrets.DOMAIN }}"

            APP_DIR="${{ secrets.EC2_APP_DIR }}"
            PM2_APP="${{ secrets.PM2_APP_NAME }}"
            APP_PORT="${{ secrets.APP_PORT }}"
            DOMAIN="${{ secrets.DOMAIN }}"
            WWW_DOMAIN="${{ secrets.WWW_DOMAIN }}"

            CURRENT_COMMIT=$(git rev-parse HEAD)
            echo $CURRENT_COMMIT > ~/.last_good_commit
            echo "Saved current commit: $CURRENT_COMMIT"

            git fetch origin
            git reset --hard origin/${{ github.ref_name }}

            cd $APP_DIR
            
            pwd
            ls

            npm ci --omit=dev

            pm2 stop $PM2_APP || true
            pm2 start src/server.js --name $PM2_APP -- -p $APP_PORT
            sleep 10

            if ! curl -fs "http://localhost:$APP_PORT/health" > /dev/null; then
              echo "Health check failed. Rolling back..."
              git reset --hard $(cat ~/.last_good_commit)
              npm ci --omit=dev
              pm2 stop $PM2_APP || true
              pm2 start src/server.js --name $PM2_APP -- -p $APP_PORT
              echo "Rolled back to last known good commit."
              exit 1
            fi

            echo "New version is healthy"

            sudo bash -c "cat > /etc/nginx/conf.d/${DOMAIN}.conf" <<EOF
            server {
                listen 80;
                server_name $DOMAIN $WWW_DOMAIN;

                location /.well-known/acme-challenge/ {
                    root /var/www/certbot;
                }

                location / {
                    return 301 https://$DOMAIN\$request_uri;
                }
            }

            server {
                listen 443 ssl;
                server_name $WWW_DOMAIN;
                
                ssl_certificate /etc/letsencrypt/live/$DOMAIN/fullchain.pem;
                ssl_certificate_key /etc/letsencrypt/live/$DOMAIN/privkey.pem;

                return 301 https://$DOMAIN\$request_uri;
            }

            server {
                listen 443 ssl;
                server_name $DOMAIN;

                ssl_certificate /etc/letsencrypt/live/$DOMAIN/fullchain.pem;
                ssl_certificate_key /etc/letsencrypt/live/$DOMAIN/privkey.pem;
                ssl_protocols TLSv1.2 TLSv1.3;
                ssl_prefer_server_ciphers on;

                location / {
                    proxy_pass http://localhost:$APP_PORT;
                    proxy_http_version 1.1;
                    proxy_cache_bypass $http_upgrade;
                    proxy_set_header Upgrade $http_upgrade;
                    proxy_set_header Connection 'upgrade';
                    proxy_set_header Host $host;
                    proxy_set_header X-Real-IP \$remote_addr;
                    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto \$scheme;
                }
            }
            EOF

            sudo nginx -t && sudo systemctl reload nginx

            sudo mkdir -p /var/www/certbot
            sudo certbot --nginx -d $DOMAIN -d $WWW_DOMAIN --non-interactive --agree-tos -m ${{ secrets.DEPLOY_EMAIL }}" || true
            if sudo certbot certificates | grep -q "VALID:"; then
              echo "No renewal needed."
            else
              echo "Attempting renewal..."
              sudo certbot renew --dry-run --non-interactive
            fi
            sudo systemctl reload nginx

            echo "EC2 Deployment completed successfully for $DOMAIN"

      - name: Revoke runner IP address
        run: |
          aws ec2 revoke-security-group-ingress \
            --group-id ${{ secrets.AWS_INSTANCE_SG_ID }} \
            --protocol tcp \
            --port 22 \
            --cidr ${{ steps.ip.outputs.ipv4 }}/32
